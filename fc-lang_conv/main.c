/***************************************************************************
 *   Copyright (C) 2019 by Chernov A.A.                                    *
 *   valexlin@gmail.com                                                    *
 *                                                                         *
 *   This program is free software: you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation, either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/

// Parse fc-lang *.orth file and produce c-include file.

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <limits.h>

#define MAX_LANG_LEN		20
#define CODE_IN_RANGE		0xF0F0FFFF		// By defifnition this is invalid code point.

int processFile(const char* langName, const char* sourceFileName, const char* destFileName);

int main(int argc, char* argv[])
{
	const char* sourceFileName = 0;
	char destFileName[MAX_LANG_LEN + 10];
	char langName[MAX_LANG_LEN + 1];
	if (argc > 1)
	{
		sourceFileName = (const char* )argv[1];
	}
	else
	{
		printf("Usage:\n");
		printf("%s <orth-file> [output-file]\n", argv[0]);
		return 1;
	}
	if (argc > 2)
	{
		strncpy(destFileName, argv[2], MAX_LANG_LEN + 9);
		destFileName[MAX_LANG_LEN + 9] = 0;
	}
	else
		destFileName[0] = 0;
	char* ptr = strrchr(sourceFileName, '/');
	if (ptr)
		strncpy(langName, ptr + 1, MAX_LANG_LEN);
	else
		strncpy(langName, sourceFileName, MAX_LANG_LEN);
	langName[MAX_LANG_LEN] = 0;
	ptr = strrchr(langName, '.');
	if (ptr)
		*ptr = 0;
	if (0 == destFileName[0])
		sprintf(destFileName, "%s_orth.c", langName);

	fprintf(stderr, "source file: %s\n", sourceFileName);
	fprintf(stderr, "destination file: %s\n", destFileName);
	fprintf(stderr, "language: %s\n", langName);

	int ret = processFile(langName, sourceFileName, destFileName);
	return ret;
}

int parseFile(const char *dirName, FILE* fin, FILE* fout);

int processFile(const char* langName, const char *sourceFileName, const char *destFileName)
{
	char* ptr;
	char *uptr, *lptr;
	int i;
	int count;

	FILE* fin = fopen(sourceFileName, "rt");
	if (NULL == fin)
	{
		fprintf(stderr, "Can't open file `%s' for reading!\n", sourceFileName);
		return 0;
	}
	FILE* fout = fopen(destFileName, "wt");
	if (NULL == fout)
	{
		fprintf(stderr, "Can't open file `%s' for writing!\n", destFileName);
		fclose(fin);
		return 0;
	}

	char dirName[PATH_MAX];
	ptr = strrchr(sourceFileName, '/');
	if (ptr)
	{
		int len = ptr - sourceFileName;
		if (len >= PATH_MAX - 1)
			len = PATH_MAX - 1;
		strncpy(dirName, sourceFileName, len);
		dirName[len] = 0;
	}
	else
		strcpy(dirName, ".");

	fprintf(stderr, "processing orth-file for language %s\n", langName);
	char langName_UC[MAX_LANG_LEN + 1];
	char langName_LC[MAX_LANG_LEN + 1];
	ptr = (char*)langName;
	uptr = langName_UC;
	lptr = langName_LC;
	i = 0;
	while (*ptr && i < MAX_LANG_LEN)
	{
		*uptr = toupper(*ptr);
		*lptr = tolower(*ptr);
		uptr++;
		lptr++;
		ptr++;
		i++;
	}
	*uptr = 0;
	*lptr = 0;
	//fprintf(fout, "#ifndef %s_LANG_ORTH_H\n", langName_UC);
	//fprintf(fout, "#define %s_LANG_ORTH_H\n", langName_UC);
	fprintf(fout, "\n");
	fprintf(fout, "// This file is autogenerated from fc-lang database.\n");
	fprintf(fout, "// https://www.freedesktop.org/wiki/Software/fontconfig/\n");
	fprintf(fout, "// https://gitlab.freedesktop.org/fontconfig/fontconfig/tree/master/fc-lang\n");
	fprintf(fout, "// by fc-lang_conv at https://github.com/virxkane/freetype_textdraw\n");
	fprintf(fout, "\n");
	fprintf(fout, "unsigned int %s_lang_orth_chars[] = {\n", langName_LC);
	count = parseFile(dirName, fin, fout);
	fprintf(fout, "};\n");
	//fprintf(fout, "unsigned int %s_lang_orth_size = %u;\n", langName_LC, count);
	fprintf(fout, "#define %s_LANG_ORTH_SZ	%u\n", langName_UC, count);
	//fprintf(fout, "\n");
	//fprintf(fout, "#endif	// %s_LANG_ORTH_H\n", langName_UC);
	fclose(fout);
	fclose(fin);
	return count > 0 ? 1 : 0;
}

int parseFile(const char *dirName, FILE* fin, FILE* fout)
{
	int count = 0;
	int ok;
	char* line = 0;
	size_t line_sz = 0;
	size_t len;
	char incFileName[PATH_MAX];
	char* ptr;
	char* eptr;
	char *endptr;
	char* saveptr;
	unsigned int first, second;
	while ( getline(&line, &line_sz, fin) != -1 )
	{
		len = strlen(line);
		if (line > 0)
		{
			if ('\n' == line[len-1])
			{
				line[len-1] = 0;
				len--;
				if ('\r' == line[len-1])
				{
					line[len-1] = 0;
					len--;
				}
			}
			ptr = line;
			// skip leading spaces
			while (*ptr && isspace(*ptr))
			{
				ptr++;
				len--;
			}
			// skip trailing spaces
			if (len > 0)
			{
				eptr = ptr + len - 1;
				while (eptr > ptr && isspace(*eptr))
				{
					*eptr = 0;
					eptr--;
					len--;
				}
			}
			// skip trailing comment
			if (len > 0)
			{
				eptr = strchr(ptr, '#');
				if (eptr)
				{
					*eptr = 0;
					len = eptr - ptr;
					// ... and then again trailing spaces
					if (len > 0)
					{
						eptr = ptr + len - 1;
						while (eptr > ptr && isspace(*eptr))
						{
							*eptr = 0;
							eptr--;
							len--;
						}
					}
				}
			}
			if (0 == len || '#' == *ptr)
				;	// skip empty or commented lines
			else
			{
				//printf("line=%s, len=%u\n", line, (unsigned int)len);
				if (strncmp(ptr, "include ", 8) == 0)
				{
					ok = 0;			// reset flag before line parsing
					saveptr = ptr;
					if (len > 9)
					{
						ptr = ptr + 8;
						while (*ptr && isspace(*ptr))
							ptr++;
						if (*ptr)
						{
							sprintf(incFileName, "%s/%s", dirName, ptr);
							FILE* newfin = fopen(incFileName, "rt");
							if (NULL != newfin)
							{
								fprintf(stderr, "processed included file: \"%s\"\n", incFileName);
								int inc_count = parseFile(dirName, newfin, fout);
								fclose(newfin);
								if (inc_count > 0)
								{
									ok = 1;
									count += inc_count;
								}
							}
						}
					}
					if (0 == ok)
						fprintf(stderr, "Failed to parse line: \"%s\"\n", saveptr);
				}
				else
				{
					ok = 0;			// reset flag before line parsing
					first = strtoul(ptr, &endptr, 16);
					if (endptr > ptr)
					{
						if (0 == *endptr)
						{
							second = 0;
							ok = 1;			// line contains one number
						}
						else
						{
							if ('-' == *endptr)
							{
								ptr = endptr + 1;
								if (*ptr)
								{
									second = strtoul(ptr, &endptr, 16);
									if (endptr > ptr && (0 == *endptr || isspace(endptr)))
										ok = 1;
								}
							}
							else if ('.' == *endptr)
							{
								ptr = endptr + 1;
								if ('.' == *ptr)
								{
									ptr++;
									if (*ptr)
									{
										second = strtoul(ptr, &endptr, 16);
										if (endptr > ptr && (0 == *endptr || isspace(endptr)))
											ok = 1;
									}
								}
							}
							else if (isspace(*endptr))
							{
								// just comment witout char '#'
								second = 0;
								ok = 1;
							}
						}
					}
					if (ok)
					{
						if (0 == second)
						{
							fprintf(fout, "\t0x%04x,\n", first);
							count++;
						}
						else
						{
							fprintf(fout, "\t0x%08x, 0x%04x, 0x%04x,	// range\n", CODE_IN_RANGE, first, second);
							count += 3;
						}
					}
				}
				if (0 == ok)
				{
					fprintf(stderr, "Failed to parse line: %s\n", line);
				}
			}
		}
	}
	if (line)
		free(line);
	return count;
}
